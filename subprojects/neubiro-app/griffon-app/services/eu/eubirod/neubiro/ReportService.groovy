/*
 * Copyright 2014-2025 Stefano Gualdi, AGENAS.
 *
 * Licensed under the European Union Public Licence (EUPL), Version 1.1 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://joinup.ec.europa.eu/software/page/eupl/licence-eupl
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package eu.eubirod.neubiro

import griffon.core.GriffonApplication
import griffon.core.artifact.GriffonService
import griffon.metadata.ArtifactProviderFor
import groovy.util.logging.Slf4j
import org.apache.commons.io.IOUtils
import org.apache.commons.io.FileUtils
import org.apache.commons.lang.StringEscapeUtils
import org.apache.commons.lang.time.StopWatch

import javax.inject.Inject
import eu.eubirod.neubiro.utils.NeubiroUtils
import com.google.code.docbook4j.renderer.PDFRenderer
import com.google.code.docbook4j.renderer.HTMLRenderer
import groovy.text.*

/**
 * @author Stefano Gualdi <stefano.gualdi@gmail.com>
 */
@Slf4j
@ArtifactProviderFor(GriffonService)
class ReportService {

  @Inject
  GriffonApplication app

  def runReportGeneration(List indicators, Map runningParams, File indicatorsDir, File workDir) {
    StopWatch timer = new StopWatch()
    timer.start()

    if (indicators.size() == 0) {
      return
    }

    log("Report generation start", 'info')

    app.eventRouter.publishEvent('ReportGenerationStarted', [indicators.size() + 1])

    try {
      File reportWorkDir = new File(workDir, 'report')
      if (!reportWorkDir.exists()) {
        reportWorkDir.mkdirs()
      }

      def xmlEngine = new GStringTemplateEngine()

      // Prepare chapter template
      def chapterTmplFile = new File(indicatorsDir, "report/chapter.xml")
      def chapterTmpl = xmlEngine.createTemplate(chapterTmplFile)

      def cleanupList = []

      // Collect all chunks to generate the final docbook xml file
      def chunks = []
      for (i in indicators) {
        if (!i.excludeReport) {
          log("Processing indicator ${i.id}")

          def indicatorOutputDir = new File(workDir, i.id)

          // Read the chunk generated by R code
          def reportChunkFile = new File(indicatorOutputDir, "report.xml")
          if (reportChunkFile.exists()) {
            def binding = [
              id   : i.id,
              title: i.description,
              body : reportChunkFile.text
            ]
            chunks << chapterTmpl.make(binding).toString()

            // Copy all files generated by R to the report work dir
            indicatorOutputDir.eachFile { f ->
              if (NeubiroUtils.splitFilename(f.name).ext in ['pdf', 'jpg', 'gif', 'png']) {
                FileUtils.copyFileToDirectory(f, reportWorkDir)
                cleanupList << new File(reportWorkDir, f.name)
              }
            }
          }
          app.eventRouter.publishEvent('ReportGenerationProgress')
        }
      }

      // Prepare the master template
      def masterTmplFile = new File(indicatorsDir, "report/master.xml")
      def masterTmpl = xmlEngine.createTemplate(masterTmplFile)

      // Copy all resources in reportWorkDir
      def sourceResourcesDir = new File(indicatorsDir, "report/resources")
      if (sourceResourcesDir.exists()) {
        def destResourcesDir = new File(reportWorkDir, "resources")
        if (!destResourcesDir.exists()) {
          destResourcesDir.mkdirs()
        }
        FileUtils.copyDirectory(sourceResourcesDir, destResourcesDir)
        cleanupList << destResourcesDir
      }

      // Compile all chunks into the final docbook report file
      def now = new Date()
      def metadata = [
        timestamp: now.format("dd-MM-yyyy HH:mm:ss")
      ]
      runningParams.each { k, v ->
        if (v instanceof String) {
          metadata[k] = StringEscapeUtils.escapeXml(v)
        } else {
          metadata[k] = v
        }
      }

      def binding = [
        metadata: metadata,
        body    : chunks.join('\n')
      ]
      def finalDocbookXml = masterTmpl.make(binding).toString()

      File reportFile = new File(reportWorkDir, "report.xml")
      reportFile.withWriter("UTF-8") { it << finalDocbookXml }

      cleanupList << reportFile

      // Prepare the renderer
      String xml = "file:${reportFile.absolutePath}"
      File xslFile = new File(indicatorsDir, "report/master.xsl")
      String xsl = "file:${xslFile.absolutePath}"

      log("Rendering PDF file")

      // Render the final PDF report
      PDFRenderer pdfRenderer = PDFRenderer.create(xml, xsl)
      File outfile = new File(reportWorkDir, "report.pdf")
      writeToFile(pdfRenderer.render(), outfile)
      log("PDF file rendering done")

      // Render the final HTML report (if requested)
      File htmlXslFile = new File(indicatorsDir, "report/master_html.xsl")
      if (htmlXslFile.exists()) {
        log("Rendering HTML file")
        String htmlXsl = "file:${htmlXslFile.absolutePath}"
        // File htmlReportWorkDir = new File(reportWorkDir, "html")
        HTMLRenderer htmlRenderer = HTMLRenderer.create(xml, htmlXsl)
        htmlRenderer.parameter("base.dir", reportWorkDir.absolutePath)
        htmlRenderer.render()
        log("HTML file rendering done")
      }

      // Cleanup temp files only if no HTML output
      if (!htmlXslFile.exists()) {
        cleanupList.each { f ->
          f.file ? f.delete() : f.deleteDir()
        }
      }

      app.eventRouter.publishEvent('ReportGenerationFinished')
    }
    catch (Exception e) {
      app.eventRouter.publishEvent('ReportGenerationError')
      log(e.message, 'error', true)
      log.error e.message, e
    }

    timer.stop()

    log("Report generation end in ${timer.toString()}", 'complete')
  }

  def writeToFile(InputStream inStream, File outfile) {
    FileOutputStream out = new FileOutputStream(outfile)
    long count = IOUtils.copyLarge(inStream, out)
    out.close()
    inStream.close()
  }

  private void log(String msg, String type = "", boolean consoleOnly = false) {
    app.eventRouter.publishEvent('WriteLog', [msg, type])
    if (!consoleOnly) {
      log.debug msg
    }
  }
}
